(window.webpackJsonp=window.webpackJsonp||[]).push([[177],{477:function(t,e,a){"use strict";a.r(e);var s=a(14),o=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"javascript-archiving-good-suggestions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-archiving-good-suggestions"}},[t._v("#")]),t._v(" Javascript: Archiving good suggestions")]),t._v(" "),e("h2",{attrs:{id:"pass-actions-with-props"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pass-actions-with-props"}},[t._v("#")]),t._v(" Pass actions with props")]),t._v(" "),e("p",[t._v("Do you know how to move actions to connect ?")]),t._v(" "),e("p",[t._v("If they are pre-lifted ( ðŸ™…let's try to avoid that in the future )")]),t._v(" "),e("p",[t._v("like this")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("connect(\n  mapStateToProps,\n  () => ({ // mapActionsToProps function\n    onEnterRoute: preLiftedActions.enterRoute,\n  })\n)\n")])])]),e("p",[t._v("if they are not pre-lifted, meaning they need dispatch function injected (ðŸ™† we should try that as much as possible, it makes our components pure)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("connect(\n  mapStateToProps,\n  { // mapActionsToProps object\n    onEnterRoute: pureActions.enterRoute,\n  }\n)\n")])])]),e("h2",{attrs:{id:"do-not-pass-implicit-proptypes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#do-not-pass-implicit-proptypes"}},[t._v("#")]),t._v(" Do not pass implicit proptypes")]),t._v(" "),e("p",[t._v("Actually can we avoid these implicit props? Or if you need something like this")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const Dropdown = ({\n  options, defaultValueIndex, onChange, minWidth, optionalReactSelectOptions\n}) => (\n  <Select\n    // ...\n    {...optionalReactSelectOptions}\n  />\n);\n")])])]),e("p",[t._v("This way you can use prop-types for that ðŸ˜ƒ")]),t._v(" "),e("p",[t._v("Yeah it seems implicit that we would like to wanna avoid by using proptypes/defaultprops.")]),t._v(" "),e("p",[t._v("In the example, shall we pass the optional props with")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// Parent component\n<Dropdown\n  optionalSelectOptions={{\n    isMulti: true,\n    selectOption: "foo",\n  }}\n/>\n\n// Dropdown/v2/index.jsx\nDropdown.propTypes = {\n  // ...\n  optionalSelectOptions: PropTypes.shape({\n    isMulti: PropTypes.string.isRequired,\n    selectOption: PropTypes.string,\n  }),\n};\n')])])]),e("p",[t._v("Then shall we gonna make proptypes with the some options that we put in the future?\n(e.g. if someone want to pass isMulti prop and it's kinda optional thing -> put it in optionalSelectOptions and write the propTypes)")]),t._v(" "),e("h2",{attrs:{id:"proptypesá„‹á…ª-immutable"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#proptypesá„‹á…ª-immutable"}},[t._v("#")]),t._v(" PropTypesì™€ Immutable")]),t._v(" "),e("ol",[e("li",[t._v("Get the value from deep Immutable object in 'connect()' and return scalar/base types.")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('Yes, but instead of something like `userSelector(state).get("displayName")` you should create a `userDisplayNameSelector(state)` selector that returns a base type `String` (the user displayName)\n')])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("So avoid using Immutable types in react components except for optimisation purpose -> "),e("code",[t._v("Yes")])]),t._v(" "),e("li",[t._v("Then what about I want to return json in 'connect()'? Choose 'Immutable' or '.toJS()' case by case would be enough?")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("For this, use `react-redux-immutable`, never use `toJS()` in the connect function, this is by far the worst for optimization.\n")])])]),e("ol",{attrs:{start:"4"}},[e("li",[t._v("ì´ë¦„ ì§“ê¸° ë°©ë²•\nif we start using selectors everywhere you might want to change how you call/name/import them, I think the following is easier to read. But this is up to you:")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" userSelectors "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"selectors/user"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("userDisplayName")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" userSelectors"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("getDisplayName")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("ol",{attrs:{start:"5"}},[e("li",[t._v("PropTypesë¥¼ Immutableë¡œ í•˜ë ¤ë©´?")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("React.PropTypes.instanceOf(Immutable.List)\n")])])]),e("h2",{attrs:{id:"dealing-with-unused-parameters"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dealing-with-unused-parameters"}},[t._v("#")]),t._v(" Dealing with unused parameters")]),t._v(" "),e("p",[t._v("Also if you want to not use a parameter you can still write seomthing like "),e("code",[t._v("(_unusedParameterA, b) =>")]),t._v(" and eslint will be ok ðŸ‘")]),t._v(" "),e("h2",{attrs:{id:"actioncreator-and-lift"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#actioncreator-and-lift"}},[t._v("#")]),t._v(" actionCreator and lift")]),t._v(" "),e("h3",{attrs:{id:"question"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#question"}},[t._v("#")]),t._v(" question")]),t._v(" "),e("p",[t._v("Who is comfortable with the "),e("code",[t._v("actionCreator")]),t._v(" and "),e("code",[t._v("lift")]),t._v(" utils? I really have a hard time understanding the reasoning behind it. It is really opaque, adds a layer of complexity and obfuscates the function signature, it also breaks possible tree-shaking of unused actions.")]),t._v(" "),e("p",[e("strong",[t._v("Using "),e("code",[t._v("actionCreator")]),t._v(" and "),e("code",[t._v("lift")])])]),t._v(" "),e("div",{staticClass:"language-// Need to import complex utils extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import {lift, actionCreator} from "../util"\n\n// Will automagically create functions using string manipulation from all caps to camelCase\nconst actions = actionCreator(fooBarTypes)\n\n// Arguments needed are totally obfuscated\nexport const getAllFooBar = lift(actions.getAllFooBar)\n')])])]),e("p",[e("strong",[t._v("Following standard redux action definition")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\n// No import, standard javascript, explicit function signature (you don't need to guess function name and arguments)\nexport const getAllFooBar = () => ({ type: fooBarTypes.GET_ALL});```\nor\n\n```// No import, standard javascript, explicit function signature (you don't need to guess function name and arguments)\nexport const getAllFoo = bar => ({ type: fooBarTypes.GET_ALL, bar});\n")])])]),e("h3",{attrs:{id:"answer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#answer"}},[t._v("#")]),t._v(" answer")]),t._v(" "),e("p",[t._v("those are just sugar to:")]),t._v(" "),e("ul",[e("li",[t._v("create the actions from the types")]),t._v(" "),e("li",[t._v("bring the dispatch directly (so you dont need to use connect from the component etc you just need to call the function)")])]),t._v(" "),e("h3",{attrs:{id:"sum-up"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sum-up"}},[t._v("#")]),t._v(" sum up")]),t._v(" "),e("ul",[e("li",[t._v("The "),e("code",[t._v("actionCreator")]),t._v(" util should be deprecated because it obfuscates function signature and it breaks tree-shaking")]),t._v(" "),e("li",[t._v("The "),e("code",[t._v("lift")]),t._v(" util should be deprecated because it re-implements a util that redux provides as "),e("code",[t._v("bindActionCreators")])]),t._v(" "),e("li",[t._v("Use "),e("code",[t._v("bindActionCreators")]),t._v(" for the following use case :")])]),t._v(" "),e("blockquote",[e("p",[t._v("Need to pass actions from "),e("code",[t._v("<Parent />")]),t._v(" that is aware of redux (that has "),e("code",[t._v("dispatch")]),t._v(" in props) down to "),e("code",[t._v("<Child />")]),t._v(" that is not aware of redux without being able to pass "),e("code",[t._v("dispatch")]),t._v(". Otherwise follow the standard pattern (declare the actions needed by the component in the "),e("code",[t._v("connect")]),t._v(" function)")])])])}),[],!1,null,null,null);e.default=o.exports}}]);